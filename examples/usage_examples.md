# Qwen Agents Usage Examples

## Example 1: Full-Stack Development Task

User Request: "Implement user authentication for my React/Node.js app with secure password handling"

Agent Orchestration:
1. `agent-organizer` analyzes requirements and assembles team
2. `backend-architect` designs secure authentication API
3. `security-auditor` reviews implementation for vulnerabilities
4. `frontend-developer` creates login/logout components
5. `test-automator` creates comprehensive test suite

Result: Complete, secure authentication system with tests and documentation.

## Example 2: Performance Optimization

User Request: "My API is slow, please optimize it"

Agent Orchestration:
1. `performance-engineer` analyzes bottlenecks
2. `database-optimizer` optimizes slow queries
3. `backend-architect` refactors inefficient endpoints
4. `test-automator` validates performance improvements

Result: Measurable performance gains with validated improvements.

## Example 3: Data Pipeline Implementation

User Request: "Create an ETL pipeline to process user activity logs"

Agent Orchestration:
1. `data-engineer` designs the ETL architecture
2. `python-pro` implements the processing logic
3. `database-optimizer` sets up efficient storage
4. `test-automator` creates validation tests
5. `deployment-engineer` sets up the deployment pipeline

Result: Production-ready ETL pipeline with monitoring and error handling.

## Example 4: Security Audit

User Request: "Audit my application for security vulnerabilities"

Agent Orchestration:
1. `security-auditor` performs comprehensive security analysis
2. `code-reviewer` examines code for security issues
3. `backend-architect` suggests architectural improvements
4. `documentation-expert` creates security documentation

Result: Complete security report with remediation steps and best practices.

## Example 5: Mobile App Development

User Request: "Build a mobile app for my e-commerce platform"

Agent Orchestration:
1. `ui-ux-designer` creates mobile-first design
2. `mobile-developer` implements cross-platform app
3. `backend-architect` designs mobile-optimized APIs
4. `test-automator` creates device-specific tests
5. `deployment-engineer` sets up app store deployment

Result: Production-ready mobile application with optimized APIs and deployment pipeline.